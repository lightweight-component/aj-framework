<html>

<head>
    <meta charset="utf-8" />
    <title>AJAXJS Web UI Demo</title>
    <link rel="stylesheet" type="text/css" href="../../dist/css/base.css" />
    <link rel="stylesheet" type="text/css" href="../common/demo.css" />
    <link rel="stylesheet" type="text/css" href="../../dist/css/css/arrow-box.css" />

    <link crossorigin="anonymous" integrity="sha384-FckWOBo7yuyMS7In0aXZ0aoVvnInlnFMwCv77x9sZpFgOonQgnBj1uLwenWVtsEj"
        href="https://lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" />
    <script src="https://lib.baomitu.com/vue/2.6.11/vue.js"></script>
</head>

<body>
    <div class="box">
        <h1>Welcome to AJAXJS Web UI</h1>
        <div>
            <menu>
                <span></span>
            </menu>
            <div class="content">
                <h2>Css Selector 查询元素</h2>
                <p>原生的 document.querySelector() 已经很方便了，那么不妨更方便一点，敲少几个字（太常用了）。我们要做的，就是安排在 Element 原型封装查询方法，命名为 $() 。另外的
                    up() 方法是为了查询父级的元素。</p>
                <pre class="prettyprint">var div  = document.body.$('.foo'); // 返回符合 className=foo 的元素，单个元素
var divs = document.body.$('div', function(item: HTMLElement, index: number){...}); // 遍历所有的 div 元素，并返回该 div 集合</pre>
                <p>方法签名：</p>
                <pre class="prettyprint"><xmp>interface Element {
    /**
    * 查找子元素
    * 
    * @param cssSelector   CSS 选择器
    * @param fn            可选，当送入该参数的时候，表示使用 querySelectorAll 来查询多个 dom 元素，故 fn 是个遍历器函数，其参数列表如 item、index、array
    * @returns 目标元素，如果没有找到返回 null
    */
    $(cssSelector: cssSelector, fn?: (item: any, index?: number, array?: []) => void): Element | NodeListOf<Element> | null,

    /**
    * 查找父元素，支持 标签名称 或 样式名称，任选其一而不能同时传。
    * 
    * @param tagName	标签名称
    * @param className	样式名称
    * @returns 父级元素，如果没有找到返回 null
    */
    up(tagName: string, className?: string): Element | null
}</xmp></pre>
                <p>原理详见<a href="https://zhangxin.blog.csdn.net/article/details/112781936" target="_blank">博客文章</a>。</p>
                <h2>函数委托</h2>
                <p>Function.prototype.delegate() 就是函数的委托，可以预先制定函数的参数具有什么，返回的就是不立刻执行的函数。函数列表可以指定部分的，不指定的就用 null
                    传入。也可以指定函数的 this 指向（类似 fn.bind(xxx) 原生方法），在 这个函数 scope 字段上指定（js 的函数也是对象，而且可以任意对其添加对象，叫“晚绑定”）。
                </p>
                <p>
                    举个例子，声明一个简单的函数 function add(x, y) { return x + y;}，假设已知 y 为 2，x 未知，可以先不管，委托一下函数 add2 =
                    add.delegate(null, 2)，我们看到第一个参数为 null，意思就是 x 先不指定，第二参数为 y = 2，那么这时候指定了参数，然后返回的也是一个 Function 类型的结果，用
                    add2 表示，但这时并不立刻对 add2 进行调用。接着我们执行 add2(1)，这时指定了第一个参数，返回结果 3。</p>

                <h2>日期格式化</h2>
                <p> 原理详见我以往博客文章：<a href="https://blog.csdn.net/zhangxin09/article/details/6111294"
                        target="_blank">《JavaScript自定义日期格式化函数》</a>，例子：</p>
                <pre class="prettyprint">interface Date {
/**
* 格式化日期
* 
* @param fmt 日期格式
*/
format(fmt: string): string
}

alert(new Date().format("yyyy-MM-dd hh:mm:ss"));</pre>

                <h2>其他更多</h2>
                <p>参见<a href="https://zhangxin.blog.csdn.net/article/details/112781936" target="_blank">博客文章</a>。</p>
            </div>
            <div class="copyright">
                <div></div>
            </div>
        </div>
    </div>
    <script src="../common/demo.js"></script>
</body>

</html>