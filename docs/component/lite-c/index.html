<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
        <title>AJ Framework-Java æœ¬åœ°ç¼“å­˜ç»„ä»¶</title>
        <meta name="description" content="AJ Framework ä¸€ä¸ªåŸºäº SpringMVC æ„å»ºçš„è½»é‡çº§æ¡†æ¶ï¼Œæ—¨åœ¨å¢å¼º SpringMVC å¹¶ä½¿å…¶æ›´å…· SpringBoot çš„ç‰¹æ€§ã€‚å®ƒæ‹¥æœ‰è®¸å¤šå°å‹ç»„ä»¶ï¼Œéå¸¸æ˜“äºä½¿ç”¨ã€‚" />
        <meta name="keywords" content="AJ Framework, ajaxjs, ajaxjs framework, java framework, web framework" />
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap&family=Noto+Sans+SC:wght@100..900&display=swap" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" /> 
        <link rel="stylesheet" href="/asset/style/main.css"/>
        <link rel="icon" type="image/x-icon" href="/asset/logo.ico"/>
        <script src="/asset/common.js"></script>
        <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?a3dec1d9b9415edd86b54c1fb3d02f19";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
        </script>
    </head>
    <body>
        <nav>
            <div>
                <div class="links">
                    <a href="/">ğŸ  é¦–é¡µ</a>
                    | âš™ï¸ æºç :
                    <a target="_blank" href="https://github.com/lightweight-component/aj-framework">Github</a>/<a target="_blank" href="https://gitcode.com/lightweight-component/aj-framework">Gitcode</a>
                    |
                    <a href="/common/contact">âœ‰ï¸ è”ç³»</a>
                </div>
                <h1>
                    <img src="/asset/logo.png" style="vertical-align: middle;height: 45px;margin-bottom: 6px;" /> 
                    AJ Framework
                </h1>
                <h3>è½»é‡çº§ Java å¿«é€Ÿå¼€å‘æ¡†æ¶
                </h3>
            </div>
        </nav>
        <div>
            <menu>
                
                <ul>
                    <li class="selected">
                        <a href="/">é¦–é¡µ</a>
                    </li>
                </ul>
                <h3>æ¡†æ¶åŸºæœ¬ç”¨æ³•</h3>
                <ul>
                    <li>
                        <a href="/framework/init">åˆå§‹åŒ–ä¸€ä¸ªé¡¹ç›®</a>
                    </li>
                    <li>
                        <a href="/framework/controller">ç®€åŒ–æ§åˆ¶å™¨ä¸ºæ¥å£</a>
                    </li>
                    <li>
                        <a href="/framework/unified-return">ç»Ÿä¸€å¯¹è±¡è¿”å›</a>
                    </li>
                    <li>
                        <a href="/framework/unified-ex">ç»Ÿä¸€å¼‚å¸¸å¤„ç†</a>
                    </li>
                    <li>
                        <a href="/framework/package">æ‰“åŒ…ä¸éƒ¨ç½²</a>
                    </li>
                </ul>
                <h3>å¸¸ç”¨ç»„ä»¶</h3>
                <ul>
                    <li>
                        <a href="/component/db">æ•°æ®åº“è®¿é—®</a>
                    </li>
                    <li>
                        <a href="/component/bean-validator/">Bean å®ä½“æ ¡éªŒ</a>
                    </li>
                    <li>
                        <a href="/component/security">å®‰å…¨ç»„ä»¶ã€ç”¨æˆ·ç³»ç»Ÿ</a>
                    </li>
                    <li>
                        <a href="/component/lite-c/">ä½¿ç”¨ç®€å•æœ¬åœ°ç¼“å­˜</a>
                    </li>
                  <li>
                       <a href="/component/cache/">ä½¿ç”¨å¤šçº§ç¼“å­˜</a>
                   </li>
                </ul>

                <h3>å…¶ä»–</h3>
                <ul>
                    <li><a href="/common/contact">è”ç³»</a></li>
                </ul>
            </menu>
            <article>
                <h1>è®¾è®¡ç›®æ ‡</h1>
<p>åŸºäº Java æœ¬åœ°çš„ç¼“å­˜ï¼Œè€Œä¸æ˜¯ Redis çš„åˆ†å¸ƒå¼ç¼“å­˜ã€‚å®ƒåº”è¯¥æ»¡è¶³ä»¥ä¸‹çš„è®¾è®¡ï¼š</p>
<ul>
<li>è®¾è®¡ä¸€å¥— Cache APIï¼Œæ´¾ç”Ÿä¸åŒçš„ç¼“å­˜å®ç°ã€‚é¦–å…ˆè‚¯å®šæ˜¯ key/value çš„æ¥å£ï¼Œç„¶åå¸¦è¶…æ—¶æ—¶é—´çš„æ§åˆ¶</li>
<li>åº”è¯¥æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½¿ç”¨<code>ConcurrentHashMap</code>æˆ–<code>LRULinkedHashMap</code></li>
<li>å®ç°ç±»ä¼¼ Redis çš„è¶…æ—¶æ§åˆ¶ï¼Œç®€å•ä¸€ç‚¹çš„å¯ä»¥è‡ªå·±åˆ é™¤è¿‡æœŸçš„ï¼Œå¤æ‚ä¸€ç‚¹çš„ç”¨ Java è‡ªå¸¦çš„çº¿ç¨‹æ±  Executors å»æ§åˆ¶</li>
<li>ç¼“å­˜æ€»æ•°çš„å®¹é‡é™åˆ¶ï¼Œé‡‡ç”¨ LRU/LFU æ·˜æ±°æœºåˆ¶</li>
<li>å…¼å®¹ Spring Cache ä½“ç³»ï¼Œå¯ä»¥é€šè¿‡ Spring çš„ç¼“å­˜æ³¨è§£æ–½åŠ åˆ°ä¸šåŠ¡æ–¹æ³•ä¸Š</li>
<li>è®¾è®¡äºŒçº§ç¼“å­˜ï¼Œä¸€çº§æœ¬åœ°ï¼ŒäºŒçº§ Redis</li>
</ul>
<p>å¯è§è¦è€ƒè™‘çš„äº‹æƒ…æŒºå¤šçš„ã€‚ä¸ºäº†é¿å…ç›®æ ‡ä¸€ä¸‹å­è¿‡äºå®å¤§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä»ç®€å•çš„å°ä¾‹å­å¼€å§‹ã€‚</p>
<h1>ç®€å•çš„ Map ç¼“å­˜</h1>
<p>è¯´èµ·ç¼“å­˜è‡ªç„¶ä¾¿ä¼šæƒ³èµ· key/value ç»“æ„ï¼Œâ€”â€”ä¹Ÿä¸çŸ¥é“è°è§„å®šç¼“å­˜å°±ä¸€å®šæ˜¯ k/v çš„ï¼Œå‘µå‘µã€‚é‚£ä¹ˆæˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ° Map æ¥åšï¼Œåˆå› ä¸ºçº¿ç¨‹å®‰å…¨çš„ç¼˜æ•…ï¼Œæˆ‘ä»¬é€‰æ‹©äº†<code>ConcurrentHashMap</code>ã€‚</p>
<pre><code class="language-java">
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
public class SimpleCache extends ConcurrentHashMap&lt;String, SimpleCache.Item&gt; {
    private final ScheduledExecutorService scheduler;

    private volatile boolean running = true;

    /**
     * ç¼“å­˜é¡¹
     */
    @Data
    public static class Item {
        String value;
        int expireSeconds;
        long addTime;

        public Item(String value, int expireSeconds) {
            this.value = value;
            this.expireSeconds = expireSeconds;
            addTime = System.currentTimeMillis();
        }
    }

    /**
     * æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–å®šæ—¶å™¨
     *
     * @param scanIntervalSeconds æ‰«æé—´éš”ï¼ˆç§’ï¼‰
     */
    public SimpleCache(int scanIntervalSeconds) {
        this.scheduler = Executors.newScheduledThreadPool(1);
        startExpirationScanner(scanIntervalSeconds);
    }

    /**
     * é»˜è®¤æ„é€ å‡½æ•°ï¼Œæ‰«æé—´éš”ä¸º 5 ç§’
     */
    public SimpleCache() {
        this(5);
    }

    /**
     * æ·»åŠ ç¼“å­˜é¡¹
     *
     * @param key           é”®
     * @param value         å€¼
     * @param expireSeconds è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
     */
    public void add(String key, String value, int expireSeconds) {
        put(key, new Item(value, expireSeconds));
        log.debug(&quot;Added item with key: {}, value: {}, expireSeconds: {}&quot;, key, value, expireSeconds);
    }

    /**
     * å¯åŠ¨å®šæ—¶æ‰«æä»»åŠ¡ï¼Œåˆ é™¤è¿‡æœŸé¡¹
     *
     * @param scanIntervalSeconds æ‰«æé—´éš”ï¼ˆç§’ï¼‰
     */
    private void startExpirationScanner(int scanIntervalSeconds) {
        scheduler.scheduleAtFixedRate(() -&gt; {
            if (running) {
                try {
                    scanAndRemoveExpiredItems();
                } catch (Exception e) {
                    log.error(&quot;Error during cache expiration scan&quot;, e);
                }
            }
        }, scanIntervalSeconds, scanIntervalSeconds, TimeUnit.SECONDS);

        log.info(&quot;Started cache expiration scanner with interval: {} seconds&quot;, scanIntervalSeconds);
    }

    /**
     * æ‰«æå¹¶åˆ é™¤è¿‡æœŸé¡¹
     */
    private void scanAndRemoveExpiredItems() {
        long currentTime = System.currentTimeMillis();

        forEach((key, item) -&gt; {
            long elapsedSeconds = (currentTime - item.addTime) / 1000;

            if (elapsedSeconds &gt; item.expireSeconds) {
                remove(key);
                log.debug(&quot;Removed expired item with key: {}&quot;, key);
            }
        });
    }

    /**
     * ä¼˜é›…å…³é—­å®šæ—¶å™¨
     */
    public void shutdown() {
        running = false;
        scheduler.shutdown();

        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
                log.warn(&quot;Scheduler did not terminate gracefully&quot;);
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
            log.warn(&quot;Interrupted during scheduler shutdown&quot;, e);
        }

        log.info(&quot;SimpleCache scheduler shut down&quot;);
    }
}
</code></pre>
<p>è¿™ä¸ªç®€å•çš„ç¼“å­˜æ”¯æŒç¼“å­˜è¿‡æœŸçš„åŠŸèƒ½ã€‚å®ƒæ˜¯é€šè¿‡çº¿ç¨‹æ± æ¯éš”äº”ç§’åœ¨åå°æ‰«æç¼“å­˜ï¼Œè¶…æ—¶äº†å°±æŠŠç¼“å­˜åˆ æ‰ã€‚ä½¿ç”¨çº¿ç¨‹æ± çš„å¥½å¤„æ˜¯ç®€å•ç›´è§‚ï¼Œé™¤äº†çº¿ç¨‹æ± è¿˜å¯ä»¥ç”¨<code>BlockingQueue</code>å®ç°ã€‚</p>
<p>è¿™ä¸ªç¼“å­˜å­˜åœ¨çš„ä¸è¶³æ˜¯æ²¡æœ‰ç¼“å­˜å®¹é‡é™åˆ¶ï¼Œå¦‚æœä¸€ä¸‹å­è¾“å…¥å¤§é‡çš„ç¼“å­˜é‚£ä¹ˆå†…å­˜å°±ä¼šçˆ†æ‰ã€‚</p>
<h1>LRU ç¼“å­˜</h1>
<p>é‚£æˆ‘ä»¬é™åˆ¶ç¼“å­˜ä¸Šé™å§ï¼Œç»™ä¸ª<code>maxCapacity</code>æœ€å¤§å®¹é‡ã€‚è¶…è¿‡è¿™ä¸ªæ•°å°±æŠŠç¼“å­˜åˆ æ‰ã€‚</p>
<pre><code class="language-java">import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

public class BoundedCache&lt;K, V&gt; {
    private final ConcurrentMap&lt;K, V&gt; cache = new ConcurrentHashMap&lt;&gt;();
    private final int maxCapacity;
    private final AtomicInteger size = new AtomicInteger(0);

    public BoundedCache(int maxCapacity) {
        this.maxCapacity = maxCapacity;
    }

    public V get(K key) {
        return cache.get(key);
    }

    public V put(K key, V value) {
        V old = cache.put(key, value);
        int currentSize = size.incrementAndGet();

        // å¦‚æœæ˜¯æ–°å¢ï¼ˆä¸æ˜¯æ›¿æ¢ï¼‰ï¼Œæ£€æŸ¥æ˜¯å¦è¶…é™
        if (old == null &amp;&amp; currentSize &gt; maxCapacity) {
            // ç®€å•ç­–ç•¥ï¼šéšæœºåˆ é™¤ä¸€ä¸ªï¼ˆå®é™…å¯ç”¨ LRU/FIFOï¼‰
            K firstKey = cache.keySet().iterator().next();
            cache.remove(firstKey);
            size.decrementAndGet();
        }
        return old;
    }

    public V remove(K key) {
        V value = cache.remove(key);
        if (value != null) {
            size.decrementAndGet();
        }
        return value;
    }

    public int size() {
        return size.get();
    }
}
</code></pre>
<p>è¯¥åŠŸèƒ½å®ç°æ˜¯å®ç°äº†ï¼Œå¯æ˜¯æ²¡æœ‰è€ƒè™‘åˆ é™¤ç­–ç•¥ï¼Œæ˜¯éšæœºåˆ é™¤ä¸€ä¸ª <em>_</em>! â€”â€”è¿™ä¸å¤ªç§‘å­¦å•Šï¼Œè€Œä¸”~è¶…æ—¶æœºåˆ¶ä¹Ÿæ²¡äº†ï¼ˆæ²¡çº¿ç¨‹åˆ é™¤ï¼Œè€Œæ˜¯ç”¨ <code>BlockingQueue </code>å®ç°ï¼‰ã€‚</p>
<p>å¥½å§~æˆ‘ä»¬å…ˆè§£å†³åˆ é™¤ç­–ç•¥çš„é—®é¢˜ï¼Œå¯ä»¥æŠŠ LRU ç®—æ³•æ´¾ç”Ÿç”¨åœºã€‚</p>
<blockquote>
<p>LRU =ï¼ˆLeast Frequently Usedï¼Œæœ€ä¸ç»å¸¸ä½¿ç”¨ï¼‰</p>
</blockquote>
<p>LRU ç®—æ³•æˆ‘ä¹‹å‰<a href="https://blog.csdn.net/zhangxin09/article/details/90482303?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522cb90e9d57f92b0f819e558edf7918f98%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=cb90e9d57f92b0f819e558edf7918f98&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-90482303-null-null.nonecase&amp;utm_term=lru&amp;spm=1018.2226.3001.4450">ä»‹ç»è¿‡</a>ã€‚åƒ<code>LinkedHashMap</code>å¤©ç„¶ç¬¦åˆ LRU è¿™ç§çš„ç»“æ„å®ç°èµ·æ¥ä¼šæ¯”è¾ƒç®€ä¾¿ã€‚Spring æœ‰å†…éƒ¨çš„ LRU ä¹Ÿæ˜¯è¿™ä¹ˆåšï¼Œåªæ˜¯å®ƒçš„ API ç”¨æ³•æœ‰ç‚¹æ€ªï¼Œéœ€è¦ä¼ ä¸ªä»€ä¹ˆå›è°ƒå‡½æ•°è¿›å»ï¼Œä¸å¦‚ k/v æ–¹ä¾¿ã€‚Spring 5 çš„ LRU è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œè€Œæ–°ç‰ˆæœ¬é‡æ–°å®ç°äº†å´å¤æ‚å¾ˆå¤šã€‚</p>
<pre><code class="language-java">
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * å¸¦é”çš„çº¿ç¨‹å®‰å…¨çš„ LRULinkedHashMap ç®€å•å®ç°
 *
 * @author &lt;a href=&quot;https://blog.csdn.net/a921122/article/details/51992713&quot;&gt;...&lt;/a&gt;
 *
 * @param &lt;K&gt;
 * @param &lt;V&gt;
 */
public class SimpleLRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
    private static final long serialVersionUID = -952299094512767664L;

    /**
     * æœ€å¤§å®¹é‡
     */
    private final int maxCapacity;

    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * å¯é‡å…¥é”
     */
    private final Lock lock = new ReentrantLock();

    /**
     * åˆ›å»ºä¸€ä¸ª LRUCache
     *
     * @param maxCapacity æœ€å¤§å®¹é‡
     */
    public SimpleLRUCache(int maxCapacity) {
        super(maxCapacity, DEFAULT_LOAD_FACTOR, true);
        this.maxCapacity = maxCapacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {
        return size() &gt; maxCapacity;
    }

    @Override
    public V get(Object key) {
        try {
            lock.lock();
            return super.get(key);
        } finally {
            lock.unlock();
        }
    }

    /**
     * å¯ä»¥æ ¹æ®å®é™…æƒ…å†µï¼Œè€ƒè™‘å¯¹ä¸åŒçš„æ“ä½œåŠ é”
     */
    @Override
    public V put(K key, V value) {
        try {
            lock.lock();
            return super.put(key, value);
        } finally {
            lock.unlock();
        }
    }

}
</code></pre>
<p>é™¤äº† LRU è¿˜æœ‰ LFUï¼ˆLeast Frequently Usedï¼Œæœ€å°‘ä½¿ç”¨é¢‘ç‡ï¼‰ï¼Œå®ç°èµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œä½†ç¼“å­˜å‘½ä¸­ç‡é«˜äº LRUï¼ˆåœ¨çƒ­ç‚¹æ•°æ®ç¨³å®šæ—¶ï¼‰ã€‚</p>
<table>
<thead>
<tr>
<th></th>
<th>LRU</th>
<th>LFU</th>
</tr>
</thead>
<tbody>
<tr>
<td>ä¼˜ç‚¹</td>
<td>å®ç°ç®€å•ï¼Œæ•ˆç‡é«˜ï¼Œé€‚åº”æ•°æ®æœ‰å±€éƒ¨æ€§åŸç†</td>
<td>ç¼“å­˜å‘½ä¸­ç‡é«˜äº LRUï¼ˆåœ¨çƒ­ç‚¹æ•°æ®ç¨³å®šæ—¶ï¼‰</td>
</tr>
<tr>
<td>ç¼ºç‚¹</td>
<td>å¯¹é«˜é¢‘çªå‘è®¿é—®ä¸æ•æ„Ÿï¼Œå¯èƒ½æ·˜æ±°â€œåˆšå˜çƒ­â€æ•°æ®</td>
<td>å®ç°å¤æ‚ï¼Œé¢‘ç‡ç»Ÿè®¡å’Œè¿‡æœŸå¤„ç†è¾ƒéš¾</td>
</tr>
<tr>
<td>é€‚åˆåœºæ™¯</td>
<td>ç¼“å­˜ã€å†…å­˜ç®¡ç†ã€é¡µé¢ç½®æ¢</td>
<td>CDNã€çƒ­ç‚¹æ•°æ®éå¸¸ç¨³å®šçš„åœºæ™¯</td>
</tr>
</tbody>
</table>
<h2>LRU vs LFU ç¤ºä¾‹</h2>
<ul>
<li>
<p>LRU ç¤ºä¾‹ï¼šå¦‚æœç¼“å­˜å®¹é‡ä¸º3ï¼Œè®¿é—®é¡ºåºä¸º A B C A Dï¼š
åˆå§‹ï¼šç©º
è®¿é—®A â†’ [A]
è®¿é—®B â†’ [A,B]
è®¿é—®C â†’ [A,B,C]
è®¿é—®A â†’ [B,C,A]
è®¿é—®D â†’ æ·˜æ±°Bï¼Œå˜ä¸º [C,A,D]</p>
</li>
<li>
<p>LFU ç¤ºä¾‹ï¼šåŒå®¹é‡ï¼Œè®¿é—®é¡ºåºä¸º A B C A Dï¼ˆAè¢«è®¿é—®ä¸¤æ¬¡ï¼‰ï¼š
åˆå§‹ï¼šç©º
è®¿é—®A â†’ [A(1)]
è®¿é—®B â†’ [A(1),B(1)]
è®¿é—®C â†’ [A(1),B(1),C(1)]
è®¿é—®A â†’ [A(2),B(1),C(1)]
è®¿é—®D â†’ æ·˜æ±°Bæˆ–Cï¼ˆé¢‘ç‡ç›¸åŒï¼Œä¸€èˆ¬æ·˜æ±°æœ€æ—©çš„ï¼‰ï¼Œå˜ä¸º [A(2),C(1),D(1)]</p>
</li>
</ul>
<p>ä¸‹é¢æˆ‘ä»¬ç”¨ LFU å®ç°ã€‚</p>
<h1>å¸¦è¶…æ—¶æœºåˆ¶çš„ LFU ç¼“å­˜</h1>
<p>ä¸‹é¢æˆ‘ä»¬æ”¹ç”¨<code>ConcurrentHashMap</code>æ¥å®ç° LFUï¼š</p>
<ul>
<li>å­˜å‚¨<code>&lt;K, V&gt;</code>æ•°æ®</li>
<li>è®°å½•æ¯ä¸ª key çš„è®¿é—®æ¬¡æ•°ï¼ˆfrequencyï¼‰</li>
<li>æ”¯æŒ get å’Œ put</li>
<li>è¶…å‡ºå®¹é‡æ—¶ï¼Œæ·˜æ±° frequency æœ€å°çš„ entry</li>
<li>get å’Œ put éƒ½ç®—ä¸€æ¬¡è®¿é—®ï¼Œé¢‘ç‡ +1</li>
</ul>
<p>æ¥ç€æˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸ªç¼“å­˜æ¡ç›®æ·»åŠ æ—¶é—´æˆ³ä¿¡æ¯ï¼Œå¹¶åœ¨è®¿é—®æˆ–æ’å…¥æ—¶æ£€æŸ¥è¿™äº›æ¡ç›®çš„å­˜æ´»æ—¶é—´ã€‚å¦‚æœæŸä¸ªæ¡ç›®è¶…è¿‡äº†è®¾å®šçš„æœ€å¤§å­˜æ´»æ—¶é—´ï¼ˆTTL, Time To Liveï¼‰ï¼Œåˆ™å°†å…¶è§†ä¸ºè¿‡æœŸå¹¶ä»ç¼“å­˜ä¸­ç§»é™¤ã€‚</p>
<p>è¿™é‡Œæˆ‘ä»¬é€šè¿‡ç»™<code>CacheEntry</code>å¢åŠ ä¸€ä¸ª<code>lastAccessed</code>å­—æ®µæ¥è®°å½•æœ€åä¸€æ¬¡è®¿é—®çš„æ—¶é—´ï¼Œå¹¶åœ¨<code>get</code>å’Œ<code>put</code>æ–¹æ³•ä¸­æ£€æŸ¥è¯¥æ¡ç›®æ˜¯å¦å·²ç»è¿‡æœŸã€‚åœ¨æ·˜æ±°è¿‡ç¨‹ä¸­ï¼Œé¦–å…ˆæ£€æŸ¥å€™é€‰è€…æ˜¯å¦å·²è¿‡æœŸï¼Œè‹¥è¿‡æœŸåˆ™ç›´æ¥ç§»é™¤ï¼Œå¦åˆ™ç»§ç»­ä¿ç•™ã€‚è¿™ç§æ–¹å¼ç¡®ä¿äº†å³ä½¿åœ¨è¾¾åˆ°æœ€å¤§å®¹é‡é™åˆ¶çš„æƒ…å†µä¸‹ï¼Œä¹Ÿå¯ä»¥æ ¹æ®è®¿é—®é¢‘ç‡å’Œè¿‡æœŸæ—¶é—´æœ‰æ•ˆç®¡ç†ç¼“å­˜å†…å®¹ã€‚</p>
<pre><code class="language-java">import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public class LFUCache&lt;K, V&gt; {
    private final ConcurrentHashMap&lt;K, CacheEntry&lt;V&gt;&gt; cache;
    private final TreeMap&lt;Integer, LinkedHashSet&lt;K&gt;&gt; freqToKeys;
    private final int capacity;
    private final long defaultTtlMillis; // é»˜è®¤ TTLï¼ˆæ¯«ç§’ï¼‰ï¼Œ0 è¡¨ç¤ºæ— é»˜è®¤
    private final AtomicInteger size = new AtomicInteger(0);

    // åå°æ¸…ç†ç›¸å…³
    private final boolean enableExpiryCleanup;

    private final long cleanupIntervalMs = 1000L;

    private ScheduledExecutorService cleanupExecutor;

    private final AtomicBoolean closed = new AtomicBoolean(false);

    public LFUCacheWithPerEntryTTL(int capacity) {
        this(capacity, 0, false); // æ— é»˜è®¤ TTL
    }

    public LFUCacheWithPerEntryTTL(int capacity, long defaultTtlSeconds, boolean enableExpiryCleanup) {
        if (capacity &lt;= 0)
            throw new IllegalArgumentException(&quot;Capacity must be positive&quot;);

        this.capacity = capacity;
        this.defaultTtlMillis = defaultTtlSeconds * 1000L;
        this.cache = new ConcurrentHashMap&lt;&gt;();
        this.freqToKeys = new TreeMap&lt;&gt;();
        this.enableExpiryCleanup = enableExpiryCleanup;

        if (enableExpiryCleanup) {
            cleanupExecutor = Executors.newSingleThreadScheduledExecutor(r -&gt; {
                Thread t = new Thread(r, &quot;LFU-Cache-Expiry-Cleaner&quot;);
                t.setDaemon(true); // å®ˆæŠ¤çº¿ç¨‹

                return t;
            });
            startExpiryCleanupTask();
        }
    }

    /**
     * è·å–å€¼ï¼Œæ£€æŸ¥æ˜¯å¦è¿‡æœŸ
     */
    public V get(K key) {
        CacheEntry&lt;V&gt; entry = cache.get(key);

        if (entry == null || isExpired(entry)) {
            // å¦‚æœè¿‡æœŸï¼Œæ¸…ç†
            if (entry != null) {
                removeFromFreqMap(entry.frequency, key);
                cache.remove(key);
                size.decrementAndGet();
            }

            return null;
        }

        increaseFrequency(key, entry);
        return entry.value;
    }

    /**
     * putï¼šä½¿ç”¨é»˜è®¤ TTLï¼ˆå¦‚æœè®¾ç½®äº†ï¼‰
     */
    public V put(K key, V value) {
        if (defaultTtlMillis &gt; 0)
            return put(key, value, (int) (defaultTtlMillis / 1000));
        else
            return put(key, value, 0); // 0 è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
    }

    /**
     * putï¼šæŒ‡å®š TTLï¼ˆå•ä½ï¼šç§’ï¼‰
     * ttlSeconds = 0 è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
     */
    public V put(K key, V value, int ttlSeconds) {
        long expireTime = (ttlSeconds &gt; 0) ? (System.currentTimeMillis() + ttlSeconds * 1000L) : Long.MAX_VALUE;
        CacheEntry&lt;V&gt; oldEntry = cache.get(key);

        if (oldEntry != null &amp;&amp; !isExpired(oldEntry)) {
            V oldValue = oldEntry.value;
            oldEntry.value = value;
            oldEntry.expireTime = expireTime;
            increaseFrequency(key, oldEntry);

            return oldValue;
        }

        // å¤„ç†æ–°å¢
        if (size.get() &gt;= capacity)
            evict(); // æ·˜æ±°ä¸€ä¸ªæ¡ç›®

        CacheEntry&lt;V&gt; newEntry = new CacheEntry&lt;&gt;(value, 1, expireTime);
        cache.put(key, newEntry);
        freqToKeys.computeIfAbsent(1, k -&gt; new LinkedHashSet&lt;&gt;()).add(key);
        size.incrementAndGet();

        return null;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
     */
    private boolean isExpired(CacheEntry&lt;V&gt; entry) {
        return System.currentTimeMillis() &gt; entry.expireTime;
    }

    /**
     * å¢åŠ é¢‘ç‡
     */
    private void increaseFrequency(K key, CacheEntry&lt;V&gt; entry) {
        if (isExpired(entry)) { // ç†è®ºä¸Šä¸ä¼šåˆ°è¿™é‡Œï¼Œä½†å®‰å…¨èµ·è§
            evictEntry(key, entry);
            return;
        }

        int oldFreq = entry.frequency;
        int newFreq = oldFreq + 1;
        entry.frequency = newFreq;

        removeFromFreqMap(oldFreq, key);
        freqToKeys.computeIfAbsent(newFreq, k -&gt; new LinkedHashSet&lt;&gt;()).add(key);
    }

    /**
     * æ·˜æ±°ä¸€ä¸ªæ¡ç›®
     * ä¼˜å…ˆæ·˜æ±°å·²è¿‡æœŸçš„æ¡ç›®ï¼Œå¦åˆ™æ·˜æ±°é¢‘ç‡æœ€ä½çš„
     */
    private void evict() {
        // å…ˆå°è¯•æ‰¾ä¸€ä¸ªè¿‡æœŸçš„æ¡ç›®æ·˜æ±°
        for (Map.Entry&lt;K, CacheEntry&lt;V&gt;&gt; entry : cache.entrySet()) {
            if (isExpired(entry.getValue())) {
                evictEntry(entry.getKey(), entry.getValue());
                return;
            }
        }

        // æ²¡æœ‰è¿‡æœŸçš„ï¼Œæ·˜æ±°é¢‘ç‡æœ€ä½çš„ï¼ˆFIFOï¼‰
        Integer minFreq = freqToKeys.firstKey();
        LinkedHashSet&lt;K&gt; candidates = freqToKeys.get(minFreq);
        K keyToEvict = candidates.iterator().next();

        CacheEntry&lt;V&gt; entry = cache.get(keyToEvict);
        evictEntry(keyToEvict, entry);
    }

    /**
     * ç»Ÿä¸€æ·˜æ±°é€»è¾‘
     */
    private void evictEntry(K key, CacheEntry&lt;V&gt; entry) {
        if (entry == null)
            return;

        removeFromFreqMap(entry.frequency, key);
        cache.remove(key);
        size.decrementAndGet();
    }

    /**
     * ä» freqToKeys ä¸­ç§»é™¤ key
     */
    private void removeFromFreqMap(int freq, K key) {
        LinkedHashSet&lt;K&gt; set = freqToKeys.get(freq);
        if (set != null) {
            set.remove(key);

            if (set.isEmpty())
                freqToKeys.remove(freq);
        }
    }

    public int size() {
        return size.get();
    }

    public void clear() {
        cache.clear();
        freqToKeys.clear();
        size.set(0);
    }

    // ç¼“å­˜æ¡ç›®
    private static class CacheEntry&lt;V&gt; {
        V value;
        int frequency;
        long expireTime; // è¿‡æœŸæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰

        public CacheEntry(V value, int frequency, long expireTime) {
            this.value = value;
            this.frequency = frequency;
            this.expireTime = expireTime;
        }
    }

    // ===================== åå°æ¸…ç†ä»»åŠ¡ =====================

    private void startExpiryCleanupTask() {
        cleanupExecutor.scheduleAtFixedRate(() -&gt; {
            if (closed.get())
                return;

            try {
                List&lt;K&gt; expiredKeys = new ArrayList&lt;&gt;();
                // æ‰«ææ‰€æœ‰æ¡ç›®ï¼Œæ”¶é›†è¿‡æœŸçš„ key
                for (Map.Entry&lt;K, CacheEntry&lt;V&gt;&gt; entry : cache.entrySet()) {
                    if (isExpired(entry.getValue()))
                        expiredKeys.add(entry.getKey());
                }

                // æ‰¹é‡æ¸…ç†
                for (K key : expiredKeys)
                    evictEntry(key, cache.get(key));

            } catch (Exception e) {
                // é˜²æ­¢ä»»åŠ¡å› å¼‚å¸¸é€€å‡º
                System.err.println(&quot;Expiry cleanup task error: &quot; + e.getMessage());
            }
        }, cleanupIntervalMs, cleanupIntervalMs, TimeUnit.MILLISECONDS);
    }

    /**
     * å…³é—­ç¼“å­˜ï¼Œé‡Šæ”¾åå°çº¿ç¨‹
     */
    public void close() {
        if (closed.compareAndSet(false, true) &amp;&amp; enableExpiryCleanup) {
            cleanupExecutor.shutdown();

            try {
                if (!cleanupExecutor.awaitTermination(3, TimeUnit.SECONDS))
                    cleanupExecutor.shutdownNow();
            } catch (InterruptedException e) {
                cleanupExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
//        LFUCacheWithPerEntryTTL&lt;String, String&gt; cache = new LFUCacheWithPerEntryTTL&lt;&gt;(3);
//
//        cache.put(&quot;A&quot;, &quot;Apple&quot;, 2);     // 2ç§’åè¿‡æœŸ
//        cache.put(&quot;B&quot;, &quot;Banana&quot;, 5);    // 5ç§’åè¿‡æœŸ
//        cache.put(&quot;C&quot;, &quot;Cherry&quot;);       // æ°¸ä¸è¿‡æœŸï¼ˆä½¿ç”¨é»˜è®¤æˆ–æ—  TTLï¼‰
//
//        System.out.println(cache.get(&quot;A&quot;)); // Apple
//        Thread.sleep(3000);
//        System.out.println(cache.get(&quot;A&quot;)); // nullï¼ˆå·²è¿‡æœŸï¼‰
//
//        System.out.println(cache.get(&quot;B&quot;)); // Banana
//        System.out.println(cache.get(&quot;C&quot;)); // Cherry

        // å¯ç”¨åå°æ¸…ç†ï¼Œæ¯ 500ms æ‰«æä¸€æ¬¡
        LFUCacheWithPerEntryTTL&lt;String, String&gt; cache2 = new LFUCacheWithPerEntryTTL&lt;&gt;(100, 500, true);

        cache2.put(&quot;A&quot;, &quot;Apple&quot;, 2);   // 2ç§’åè¿‡æœŸ
        cache2.put(&quot;B&quot;, &quot;Banana&quot;, 5);  // 5ç§’åè¿‡æœŸ

        System.out.println(&quot;1så: &quot; + cache2.get(&quot;A&quot;)); // Apple
        Thread.sleep(3000);
        System.out.println(&quot;3så: &quot; + cache2.get(&quot;A&quot;)); // nullï¼ˆåå°æˆ–getæ—¶å·²æ¸…ç†ï¼‰

        // å…³é—­ç¼“å­˜ï¼Œé‡Šæ”¾çº¿ç¨‹
        cache2.close();
    }
}
</code></pre>
<p>å¦å¤–è¿˜å¢åŠ äº†å®šæœŸæ¸…ç†çš„åŠŸèƒ½ï¼šæ·»åŠ ä¸€ä¸ªåå°çº¿ç¨‹æˆ–ä½¿ç”¨å®šæ—¶ä»»åŠ¡æ¥å®šæœŸæ‰«æå’Œæ¸…é™¤è¿‡æœŸæ¡ç›®ã€‚ä½†è¿™ä¸æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥åœ¨æ¯æ¬¡è®¿é—®æ—¶è¿›è¡Œæ¸…ç†ã€‚å¥½å¤„æ˜¯é¿å… get æ—¶å¡é¡¿ã€‚å½“ç„¶å¢åŠ çº¿ç¨‹ä¹Ÿä¼šå¸¦æ¥ä¸€å®šçš„å¤æ‚ï¼ˆéœ€è¦<code>close()</code>ï¼‰,äºæ˜¯æˆ‘ä»¬é€šè¿‡æ„é€ å‚æ•°å¼€å¯/å…³é—­ï¼ˆ<code>enableExpiryCleanup = true/false</code>ï¼‰æ˜¯å¦å…è®¸æ‰“å¼€åå°çº¿ç¨‹æ¸…ç†ã€‚</p>
<ul>
<li>å¤§ç¼“å­˜å»ºè®®å¯ç”¨ï¼šå¦‚æœç¼“å­˜æ¡ç›®å¤šï¼Œå»ºè®®å¯ç”¨åå°æ¸…ç†</li>
<li>å°ç¼“å­˜å¯å…³é—­ï¼šæ¡ç›®å°‘æ—¶ï¼Œget æ—¶æ¸…ç†å°±å¤Ÿäº†</li>
<li>å¦‚æœä½¿ç”¨äº†åå°æ¸…ç†ï¼Œè¯·ä¸è¦å¿˜è®°è°ƒç”¨<code>close()</code>ï¼šå°¤å…¶æ˜¯åœ¨åº”ç”¨å…³é—­æ—¶ï¼Œé¿å…çº¿ç¨‹æ³„æ¼</li>
</ul>
<p>è‡³æ­¤ï¼Œå…³äºç¼“å­˜çš„æ ¸å¿ƒåŠŸèƒ½å·²ç»å®Œæˆäº†ï¼š</p>
<ul>
<li>è®¾è®¡ä¸€å¥— Cache APIï¼Œæ´¾ç”Ÿä¸åŒçš„ç¼“å­˜å®ç°ã€‚é¦–å…ˆè‚¯å®šæ˜¯ key/value çš„æ¥å£ï¼Œç„¶åå¸¦è¶…æ—¶æ—¶é—´çš„æ§åˆ¶</li>
<li><s>åº”è¯¥æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½¿ç”¨<code>ConcurrentHashMap</code>æˆ–<code>LRULinkedHashMap</code></s></li>
<li><s>å®ç°ç±»ä¼¼ Redis çš„è¶…æ—¶æ§åˆ¶ï¼Œç®€å•ä¸€ç‚¹çš„å¯ä»¥è‡ªå·±åˆ é™¤è¿‡æœŸçš„ï¼Œå¤æ‚ä¸€ç‚¹çš„ç”¨ Java è‡ªå¸¦çš„çº¿ç¨‹æ±  Executors å»æ§åˆ¶</s></li>
<li><s>ç¼“å­˜æ€»æ•°çš„å®¹é‡é™åˆ¶ï¼Œé‡‡ç”¨ LRU/LFU æ·˜æ±°æœºåˆ¶</s></li>
<li>å…¼å®¹ Spring Cache ä½“ç³»ï¼Œå¯ä»¥é€šè¿‡ Spring çš„ç¼“å­˜æ³¨è§£æ–½åŠ åˆ°ä¸šåŠ¡æ–¹æ³•ä¸Š</li>
<li>è®¾è®¡äºŒçº§ç¼“å­˜ï¼Œä¸€çº§æœ¬åœ°ï¼ŒäºŒçº§ Redis</li>
</ul>
<p>å‰©ä¸‹ç»§ç»­å®Œæˆ~</p>
<h1>ç»Ÿä¸€ Cache API</h1>
<p>è¿™ä¸ªå°±ç®€å•äº†ï¼Œå£°æ˜ä¸€ä¸‹<code>Cache</code>æ¥å£åŠå…¶æ¡ç›®ã€‚</p>
<pre><code class="language-java">/**
 * ç¼“å­˜æ¥å£
 *
 * @param &lt;K&gt; é”®ç±»å‹
 * @param &lt;V&gt; å€¼ç±»å‹
 */
public interface Cache&lt;K, V&gt; {
    /**
     * å°†å¯¹è±¡åŠ å…¥åˆ°ç¼“å­˜
     *
     * @param key     é”®
     * @param value   å¯¹è±¡
     * @param timeout è¿‡æœŸæ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’ï¼Œ 0è¡¨ç¤ºæ— é™é•¿
     */
    void put(K key, V value, long timeout);

    default void put(K key, V value, int timeout) {
        put(key, value, timeout * 1000L);
    }

    default void put(K key, V value) {
        put(key, value, 0);
    }

    /**
     * ä»ç¼“å­˜ä¸­è·å¾—å¯¹è±¡
     *
     * @param key é”®
     * @return é”®å¯¹åº”çš„å¯¹è±¡
     */
    V get(K key);

    /**
     * æ ¹æ®æŒ‡å®šçš„é”®è·å–ç›¸åº”çš„å€¼ï¼Œå¹¶å°†è¯¥å€¼è½¬æ¢ä¸ºæŒ‡å®šçš„ç±»å‹è¿”å›ã€‚
     *
     * @param key é”®
     * @param clz æŒ‡å®šçš„ç±»
     * @param &lt;T&gt; æœŸæœ›çš„ç±»å‹
     * @return è½¬æ¢åçš„å€¼
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default &lt;T&gt; T get(K key, Class&lt;T&gt; clz) {
        V v = get(key);

        return (T) v;
    }

    /**
     * ä»ç¼“å­˜ä¸­åˆ é™¤å¯¹è±¡
     *
     * @param key é”®
     */
    void remove(K key);
}

/**
 * è¢«ç¼“å­˜çš„æ•°æ®
 *
 * @param &lt;V&gt; ç¼“å­˜æ•°æ®çš„ç±»å‹
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CacheItem&lt;V&gt; {
    /**
     * ç¼“å­˜å€¼
     */
    private V value;

    /**
     * åˆ°æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
     */
    private long expire;
}
</code></pre>
<p>è¿™æ ·ï¼Œå‰é¢çš„<code>LFUCache</code>åŠå…¶çš„å†…éƒ¨ç±»æ”¹å†™ä¸‹ã€‚</p>
<pre><code class="language-java">package com.ajaxjs.framework.cache.smallredis.lfu;

import com.ajaxjs.framework.cache.smallredis.Cache;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * TODO TreeMap å’Œ LinkedHashSet ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ‰€ä»¥éœ€è¦åŠ é”æˆ–ä½¿ç”¨ ConcurrentSkipListMap
 *
 * @param &lt;K&gt;
 * @param &lt;V&gt;
 */
public class LFUCache&lt;K, V&gt; implements Cache&lt;K, V&gt; {
    private final ConcurrentHashMap&lt;K, LFUCacheItem&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;();
    private final TreeMap&lt;Integer, LinkedHashSet&lt;K&gt;&gt; freqToKeys = new TreeMap&lt;&gt;();

    //     æ›¿ä»£ TreeMap&lt;Integer, LinkedHashSet&lt;K&gt;&gt;=new TreeMap&lt;&gt;();
//    private final ConcurrentSkipListMap&lt;Integer, KeySet&gt; freqToKeys = new ConcurrentSkipListMap&lt;&gt;();
    private final int capacity;
    private final long defaultTtlMillis; // é»˜è®¤ TTLï¼ˆæ¯«ç§’ï¼‰ï¼Œ0 è¡¨ç¤ºæ— é»˜è®¤
    private final AtomicInteger size = new AtomicInteger(0);

    // åå°æ¸…ç†ç›¸å…³
    private final boolean enableExpiryCleanup;

    private final long cleanupIntervalMs = 1000L;

    private ScheduledExecutorService cleanupExecutor;

    private final AtomicBoolean closed = new AtomicBoolean(false);

    public LFUCache(int capacity) {
        this(capacity, 0, false); // æ— é»˜è®¤ TTL
    }

    public LFUCache(int capacity, long defaultTtlSeconds, boolean enableExpiryCleanup) {
        if (capacity &lt;= 0)
            throw new IllegalArgumentException(&quot;Capacity must be positive&quot;);

        this.capacity = capacity;
        this.defaultTtlMillis = defaultTtlSeconds * 1000L;
        this.enableExpiryCleanup = enableExpiryCleanup;

        if (enableExpiryCleanup) {
            cleanupExecutor = Executors.newSingleThreadScheduledExecutor(r -&gt; {
                Thread t = new Thread(r, &quot;LFU-Cache-Expiry-Cleaner&quot;);
                t.setDaemon(true); // å®ˆæŠ¤çº¿ç¨‹

                return t;
            });
            startExpiryCleanupTask();
        }
    }

    /**
     * è·å–å€¼ï¼Œæ£€æŸ¥æ˜¯å¦è¿‡æœŸ
     */
    @Override
    public V get(K key) {
        LFUCacheItem&lt;V&gt; entry = cache.get(key);

        if (entry == null || isExpired(entry)) {
            // å¦‚æœè¿‡æœŸï¼Œæ¸…ç†
            if (entry != null) {
                removeFromFreqMap(entry.getFrequency(), key);
                cache.remove(key);
                size.decrementAndGet();
            }

            return null;
        }

        increaseFrequency(key, entry);
        return entry.getValue();
    }

    /**
     * putï¼šä½¿ç”¨é»˜è®¤ TTLï¼ˆå¦‚æœè®¾ç½®äº†ï¼‰
     */
    @Override
    public void put(K key, V value) {
        if (defaultTtlMillis &gt; 0)
            put(key, value, defaultTtlMillis);
        else
            put(key, value, 0); // 0 è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
    }

    @Override
    public void put(K key, V value, long ttl) {
        put(key, value, (int) (ttl / 1000));
    }

    /**
     * putï¼šæŒ‡å®š TTLï¼ˆå•ä½ï¼šç§’ï¼‰
     * ttlSeconds = 0 è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
     */
    @Override
    public void put(K key, V value, int ttlSeconds) {
        long expireTime = (ttlSeconds &gt; 0) ? (System.currentTimeMillis() + ttlSeconds * 1000L) : Long.MAX_VALUE;
        LFUCacheItem&lt;V&gt; oldEntry = cache.get(key);

        if (oldEntry != null &amp;&amp; !isExpired(oldEntry)) {
            V oldValue = oldEntry.getValue();
            oldEntry.setValue(value);
            oldEntry.setExpire(expireTime);
            increaseFrequency(key, oldEntry);
        }

        // å¤„ç†æ–°å¢
        if (size.get() &gt;= capacity)
            evict(); // æ·˜æ±°ä¸€ä¸ªæ¡ç›®

        LFUCacheItem&lt;V&gt; newEntry = new LFUCacheItem&lt;&gt;(value, 1, expireTime);
        cache.put(key, newEntry);
        freqToKeys.computeIfAbsent(1, k -&gt; new LinkedHashSet&lt;&gt;()).add(key);
        size.incrementAndGet();
    }

    /**
     * æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
     */
    private boolean isExpired(LFUCacheItem&lt;V&gt; entry) {
        return System.currentTimeMillis() &gt; entry.getExpire();
    }

    /**
     * å¢åŠ é¢‘ç‡
     */
    private void increaseFrequency(K key, LFUCacheItem&lt;V&gt; entry) {
        if (isExpired(entry)) { // ç†è®ºä¸Šä¸ä¼šåˆ°è¿™é‡Œï¼Œä½†å®‰å…¨èµ·è§
            evictEntry(key, entry);
            return;
        }

        int oldFreq = entry.getFrequency();
        int newFreq = oldFreq + 1;
        entry.setFrequency(newFreq);

        removeFromFreqMap(oldFreq, key);
        freqToKeys.computeIfAbsent(newFreq, k -&gt; new LinkedHashSet&lt;&gt;()).add(key);
    }

    /**
     * æ·˜æ±°ä¸€ä¸ªæ¡ç›®
     * ä¼˜å…ˆæ·˜æ±°å·²è¿‡æœŸçš„æ¡ç›®ï¼Œå¦åˆ™æ·˜æ±°é¢‘ç‡æœ€ä½çš„
     */
    private void evict() {
        // å…ˆå°è¯•æ‰¾ä¸€ä¸ªè¿‡æœŸçš„æ¡ç›®æ·˜æ±°
        for (Map.Entry&lt;K, LFUCacheItem&lt;V&gt;&gt; entry : cache.entrySet()) {
            if (isExpired(entry.getValue())) {
                evictEntry(entry.getKey(), entry.getValue());
                return;
            }
        }

        // æ²¡æœ‰è¿‡æœŸçš„ï¼Œæ·˜æ±°é¢‘ç‡æœ€ä½çš„ï¼ˆFIFOï¼‰
        Integer minFreq = freqToKeys.firstKey();
        LinkedHashSet&lt;K&gt; candidates = freqToKeys.get(minFreq);
        K keyToEvict = candidates.iterator().next();

        LFUCacheItem&lt;V&gt; entry = cache.get(keyToEvict);
        evictEntry(keyToEvict, entry);
    }

    /**
     * ç»Ÿä¸€æ·˜æ±°é€»è¾‘
     */
    private void evictEntry(K key, LFUCacheItem&lt;V&gt; entry) {
        removeFromFreqMap(entry.getFrequency(), key);
        cache.remove(key);
        size.decrementAndGet();
    }

    /**
     * ä»ç¼“å­˜ä¸­åˆ é™¤å¯¹è±¡
     *
     * @param key é”®
     */
    public void remove(K key) {
        LFUCacheItem&lt;V&gt; entry = cache.get(key);

        if (entry != null)
            evictEntry(key, entry);
    }

    /**
     * ä» freqToKeys ä¸­ç§»é™¤ key
     */
    private void removeFromFreqMap(int freq, K key) {
        LinkedHashSet&lt;K&gt; set = freqToKeys.get(freq);

        if (set != null) {
            set.remove(key);

            if (set.isEmpty())
                freqToKeys.remove(freq);
        }
    }

    public int size() {
        return size.get();
    }

    public void clear() {
        cache.clear();
        freqToKeys.clear();
        size.set(0);
    }

    // ===================== åå°æ¸…ç†ä»»åŠ¡ =====================
    private void startExpiryCleanupTask() {
        cleanupExecutor.scheduleAtFixedRate(() -&gt; {
            if (closed.get())
                return;

            try {
                List&lt;K&gt; expiredKeys = new ArrayList&lt;&gt;();
                // æ‰«ææ‰€æœ‰æ¡ç›®ï¼Œæ”¶é›†è¿‡æœŸçš„ key
                for (Map.Entry&lt;K, LFUCacheItem&lt;V&gt;&gt; entry : cache.entrySet()) {
                    if (isExpired(entry.getValue()))
                        expiredKeys.add(entry.getKey());
                }

                // æ‰¹é‡æ¸…ç†
                for (K key : expiredKeys)
                    evictEntry(key, cache.get(key));

            } catch (Exception e) {
                // é˜²æ­¢ä»»åŠ¡å› å¼‚å¸¸é€€å‡º
                System.err.println(&quot;Expiry cleanup task error: &quot; + e.getMessage());
            }
        }, cleanupIntervalMs, cleanupIntervalMs, TimeUnit.MILLISECONDS);
    }

    /**
     * å…³é—­ç¼“å­˜ï¼Œé‡Šæ”¾åå°çº¿ç¨‹
     */
    public void close() {
        if (closed.compareAndSet(false, true) &amp;&amp; enableExpiryCleanup) {
            cleanupExecutor.shutdown();

            try {
                if (!cleanupExecutor.awaitTermination(3, TimeUnit.SECONDS))
                    cleanupExecutor.shutdownNow();
            } catch (InterruptedException e) {
                cleanupExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
//        LFUCacheWithPerEntryTTL&lt;String, String&gt; cache = new LFUCacheWithPerEntryTTL&lt;&gt;(3);
//
//        cache.put(&quot;A&quot;, &quot;Apple&quot;, 2);     // 2ç§’åè¿‡æœŸ
//        cache.put(&quot;B&quot;, &quot;Banana&quot;, 5);    // 5ç§’åè¿‡æœŸ
//        cache.put(&quot;C&quot;, &quot;Cherry&quot;);       // æ°¸ä¸è¿‡æœŸï¼ˆä½¿ç”¨é»˜è®¤æˆ–æ—  TTLï¼‰
//
//        System.out.println(cache.get(&quot;A&quot;)); // Apple
//        Thread.sleep(3000);
//        System.out.println(cache.get(&quot;A&quot;)); // nullï¼ˆå·²è¿‡æœŸï¼‰
//
//        System.out.println(cache.get(&quot;B&quot;)); // Banana
//        System.out.println(cache.get(&quot;C&quot;)); // Cherry

        // å¯ç”¨åå°æ¸…ç†ï¼Œæ¯ 500ms æ‰«æä¸€æ¬¡
        LFUCache&lt;String, String&gt; cache2 = new LFUCache&lt;&gt;(100, 500, true);

        cache2.put(&quot;A&quot;, &quot;Apple&quot;, 2);   // 2ç§’åè¿‡æœŸ
        cache2.put(&quot;B&quot;, &quot;Banana&quot;, 5);  // 5ç§’åè¿‡æœŸ

        System.out.println(&quot;1så: &quot; + cache2.get(&quot;A&quot;)); // Apple
        Thread.sleep(3000);
        System.out.println(&quot;3så: &quot; + cache2.get(&quot;A&quot;)); // nullï¼ˆåå°æˆ–getæ—¶å·²æ¸…ç†ï¼‰

        // å…³é—­ç¼“å­˜ï¼Œé‡Šæ”¾çº¿ç¨‹
        cache2.close();
    }
}

package com.ajaxjs.framework.cache.smallredis.lfu;

import com.ajaxjs.framework.cache.smallredis.CacheItem;
import lombok.Data;
import lombok.EqualsAndHashCode;

@EqualsAndHashCode(callSuper = true)
@Data
public class LFUCacheItem&lt;V&gt; extends CacheItem&lt;V&gt; {
    private int frequency;

    public LFUCacheItem(V value, int frequency, long expire) {
        super(value, expire);
        this.frequency = frequency;
    }
}

</code></pre>
<h1>æ•´åˆåˆ° Spring Cache</h1>
<p>Spring 3.1å¼€å§‹ï¼Œå¼•å…¥äº†Spring Cacheï¼Œå³Springç¼“å­˜æŠ½è±¡ã€‚é€šè¿‡å®šä¹‰<code>springframework.cache.Cache</code>å’Œ<code>org.springframework.cache.CacheManager</code>æ¥å£æ¥ç»Ÿä¸€ä¸åŒçš„ç¼“å­˜æŠ€æœ¯ï¼Œå¹¶æ”¯æŒä½¿ç”¨æ³¨è§£ç®€åŒ–å¼€å‘è¿‡ç¨‹ã€‚</p>
<ul>
<li>Cacheæ¥å£ï¼šä¸ºç¼“å­˜çš„ç»„ä»¶è§„èŒƒå®šä¹‰ï¼ŒåŒ…å«ç¼“å­˜çš„ get put evict å„ç§æ“ä½œé›†åˆã€‚</li>
<li>CacheManagerï¼šåŸºäº name ç®¡ç†ä¸€ç»„ Cacheï¼ŒæŒ‡å®šç¼“å­˜çš„åº•å±‚å®ç°ã€‚ä¾‹å¦‚ RedisCacheï¼ŒEhCacheCacheï¼ŒConcurrentMapCache ç­‰ï¼Œä¹Ÿå®ç°æˆ‘ä»¬è‡ªå·±çš„åº•å±‚å®ç°ï¼Œæ¯”å¦‚å½“å‰çš„ LFUCacheã€‚</li>
</ul>
<p>ç®€å•è¯´ï¼Œå°±æ˜¯åœ¨ä¸šåŠ¡å±‚çš„æ–¹æ³•ä¸Šæ·»åŠ <code>@Cacheable</code>æ³¨è§£å³å¯å¯ç”¨ç¼“å­˜ï¼Œéå¸¸è½»æ¾çš„å®ç°äº†ç¼“å­˜æ“ä½œçš„å¤„ç†ï¼Œæ•´ä½“çš„å®ç°æ•ˆæœæ˜¯éå¸¸ç®€å•çš„ï¼ŒåŒæ—¶ä¹Ÿé¿å…å½±å“å…¶ä»–æ•°æ®å±‚çš„ç¼“å­˜æ“ä½œã€‚æ¯æ¬¡æ‰§è¡Œè¯¥æ–¹æ³•å‰ä¼šå…ˆå»ç¼“å­˜ä¸­æŸ¥æœ‰æ²¡æœ‰ç›¸åŒæ¡ä»¶ä¸‹ï¼Œç¼“å­˜çš„æ•°æ®ï¼Œæœ‰çš„è¯ç›´æ¥æ‹¿ç¼“å­˜çš„æ•°æ®ï¼Œæ²¡æœ‰çš„è¯æ‰§è¡Œæ–¹æ³•ï¼Œå¹¶å°†æ‰§è¡Œç»“æœè¿”å›ã€‚</p>
<pre><code class="language-java">import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class EmpService {
    //ç¼–è¾‘é›‡å‘˜
    public Emp edit(Emp emp) {
        return Emp.builder().build();
    }

    //æ ¹æ®idæŸ¥è¯¢é›‡å‘˜ä¿¡æ¯
    @Cacheable(cacheNames = &quot;emp&quot;)
    public Emp get(String eid) {
        return Emp.builder().ename(&quot;Tom&quot;).build();
    }

    //æ ¹æ®åç§°æŸ¥è¯¢é›‡å‘˜ä¿¡æ¯
    @Cacheable(cacheNames = &quot;emp&quot;)
    public Emp getEname(String ename) {
        return Emp.builder().ename(&quot;Jack&quot;).build();
    }
}
</code></pre>
<p>é…ç½®<code>LfuSpringCacheManager</code>ï¼š</p>
<pre><code class="language-java">import com.ajaxjs.framework.cache.lfu.springcache.LfuSpringCacheManager;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableCaching//å¼€å¯ç¼“å­˜
@ComponentScan(basePackages = &quot;com.ajaxjs.framework.cache&quot;)
public class Config {
    @Bean
    public CacheManager cacheManager() {
        return new LfuSpringCacheManager(100); // LRU å®¹é‡ä¸º 100ï¼Œå¯è‡ªè¡Œè°ƒæ•´
    }
}
</code></pre>
<p><code>LfuSpringCacheManager</code>å’Œ<code>LfuSpringCache</code>æºç ï¼š</p>
<pre><code class="language-java">
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class LfuSpringCacheManager implements CacheManager {
    private final Map&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;();
    private final int maxSize;

    public LfuSpringCacheManager(int maxSize) {
        this.maxSize = maxSize;
    }

    @Override
    public Cache getCache(String name) {
        return cacheMap.computeIfAbsent(name, n -&gt; new LfuSpringCache(n, maxSize));
    }

    @Override
    public Collection&lt;String&gt; getCacheNames() {
        return Collections.unmodifiableSet(cacheMap.keySet());
    }
}


import com.ajaxjs.framework.cache.lfu.LFUCache;
import org.springframework.cache.Cache;
import org.springframework.cache.support.SimpleValueWrapper;

import java.util.concurrent.Callable;

public class LfuSpringCache implements Cache {
    private final String name;

    private final LFUCache&lt;String, Object&gt; lfuCache;

    public LfuSpringCache(String name, int maxSize) {
        this.name = name;
        this.lfuCache = new LFUCache&lt;&gt;(maxSize);
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Object getNativeCache() {
        return lfuCache;
    }

    @Override
    public ValueWrapper get(Object key) {
        Object value = lfuCache.get(key.toString());
        System.out.println(&quot;LFU Cache: &quot; + value);

        return value != null ? new SimpleValueWrapper(value) : null;
    }

    @Override
    public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) {
        Object value = lfuCache.get(key.toString());

        if (type != null &amp;&amp; type.isInstance(value))
            return type.cast(value);

        return null;
    }

    @Override
    public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) {
        return null;
    }

    @Override
    public void put(Object key, Object value) {
        lfuCache.put(key.toString(), value);
    }

    @Override
    public void evict(Object key) {
        lfuCache.remove(key.toString());
    }

    @Override
    public void clear() {
        lfuCache.clear();
    }
}
</code></pre>
<p>è¿è¡Œæµ‹è¯•ï¼š</p>
<pre><code class="language-java">
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.cache.support.AbstractCacheManager;
import org.springframework.test.context.ContextConfiguration;

@Slf4j
@SpringBootTest
@ContextConfiguration(classes = Config.class)
public class TestCache {
    @Autowired
    EmpService service;

    @Test
    void testGet() {
        AbstractCacheManager l;
        Emp emp1 = service.get(&quot;1&quot;);
        log.info(&quot;[ç¬¬ä¸€æ¬¡æŸ¥è¯¢],emp1:{}&quot;, emp1);

        Emp emp2 = service.get(&quot;1&quot;);
        log.info(&quot;[ç¬¬äºŒæ¬¡æŸ¥è¯¢],emp2:{}&quot;, emp2);
    }
}

</code></pre>
<p><img src="https://i-blog.csdnimg.cn/direct/5a4f0612e3be42bab45d4f98076c6070.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°">
å¯è§ç¬¬äºŒæ¬¡æ‰§è¡Œçš„æ—¶å€™ï¼Œå‘½ä¸­äº†ç¼“å­˜ã€‚</p>
<p>Spring Cache è¿˜æœ‰å…¶ä»–å¼ºå¤§çš„ç”¨æ³•ï¼Œè¿™é‡Œå°±ä¸å±•å¼€ä»‹ç»äº†ã€‚</p>
<h1>äºŒçº§ç¼“å­˜</h1>
<p>è¿™ä¸ªå®ç°èµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œå¦æ–‡å†è¿°ã€‚</p>
<h1>æºç </h1>
<p>æ‰€æœ‰æºç åœ¨ aj-frameworkï¼š<a href="https://gitcode.com/lightweight-component/aj-framework/tree/master/aj-framework/src/main/java/com/ajaxjs/framework/cache">https://gitcode.com/lightweight-component/aj-framework/tree/master/aj-framework/src/main/java/com/ajaxjs/framework/cache</a>ã€‚</p>
<h1>å‚è€ƒï¼š</h1>
<ul>
<li><a href="https://blog.hackyle.com/article/java-demo/springcache-redis">ã€ŠSpring Cacheæ•´åˆ Redisã€‹</a></li>
<li><a href="https://blog.csdn.net/weixin_43695916/article/details/128038078">ã€ŠSpring Cache ç»„ä»¶ã€‹</a></li>
<li><a href="https://www.cnblogs.com/rongdi/p/9057208.html">ã€ŠSpring Boot ä¸­ä½¿ç”¨è‡ªå®šä¹‰ä¸¤çº§ç¼“å­˜ã€‹</a></li>
<li><a href="https://www.baeldung.com/spring-cache-tutorial">A Guide To Caching in Spring</a></li>
</ul>

            </article>
        </div>
        <footer>
             å¼€æºæ¡†æ¶ <a href="https://framework.ajaxjs.com" target="_blank">AJ-Framework</a> é¦–é¡µã€‚è”ç³»æ–¹å¼ï¼š
             frank@ajaxjs.comï¼Œ<a href="https://blog.csdn.net/zhangxin09" target="_blank">ä½œè€…åšå®¢</a>
             <br />
             <br />
             Copyright Â© 2025 Frank Cheung. All rights reserved.
         </footer>
    </body>
</html>